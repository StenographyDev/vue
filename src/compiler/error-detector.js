/* @flow */

import { dirRE, onRE } from './parser/index'

type Range = { start?: number, end?: number };

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
const prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b')

// these unary operators should not be used as property/method names
const unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)')

// strip strings in expressions
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g

// detect problematic expressions in a template
 /*
 This code is checking the ASTNode for errors
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
export function detectErrors (ast: ?ASTNode, warn: Function) {
  if (ast) {
    checkNode(ast, warn)
  }
}

 /*
 This code is checking the attributes of each node in the AST. It's doing this by iterating through all of the nodes and checking if they have a type attribute, which means that it's an element node. If so, then we're going to loop through all of its attributes and check for any directives (vfor or vslot).
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
function checkNode (node: ASTNode, warn: Function) {
  if (node.type === 1) {
    for (const name in node.attrsMap) {
      if (dirRE.test(name)) {
        const value = node.attrsMap[name]
        if (value) {
          const range = node.rawAttrsMap[name]
          if (name === 'v-for') {
            checkFor(node, `v-for="${value}"`, warn, range)
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, `${name}="${value}"`, warn, range)
          } else if (onRE.test(name)) {
            checkEvent(value, `${name}="${value}"`, warn, range)
          } else {
            checkExpression(value, `${name}="${value}"`, warn, range)
          }
        }
      }
    }
    if (node.children) {
      for (let i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn)
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node)
  }
}

 /*
 This code is checking for JavaScript unary operators in the expression.
 The code block checks if there are any JavaScript unary operators in the expression and warns about it.
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
function checkEvent (exp: string, text: string, warn: Function, range?: Range) {
  const stripped = exp.replace(stripStringRE, '')
  const keywordMatch: any = stripped.match(unaryOperatorsRE)
  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn(
      `avoid using JavaScript unary operator as property name: ` +
      `"${keywordMatch[0]}" in expression ${text.trim()}`,
      range
    )
  }
  checkExpression(exp, text, warn, range)
}

 /*
 This code is checking for the `for` attribute of an element. If it exists, then we are going to check if the value of that attribute is a valid expression.
 If it isn't, then we will warn about this and provide some context in which to fix the issue.
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
function checkFor (node: ASTElement, text: string, warn: Function, range?: Range) {
  checkExpression(node.for || '', text, warn, range)
  checkIdentifier(node.alias, 'v-for alias', text, warn, range)
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range)
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range)
}

 /*
 This code is checking if the variable name in an expression is valid
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
function checkIdentifier (
  ident: ?string,
  type: string,
  text: string,
  warn: Function,
  range?: Range
) {
  if (typeof ident === 'string') {
    try {
      new Function(`var ${ident}=_`)
    } catch (e) {
      warn(`invalid ${type} "${ident}" in expression: ${text.trim()}`, range)
    }
  }
}

 /*
 This code is checking if the expression contains a JavaScript keyword. If it does, then we warn the user that they should avoid using keywords as property names.
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
function checkExpression (exp: string, text: string, warn: Function, range?: Range) {
  try {
    new Function(`return ${exp}`)
  } catch (e) {
    const keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE)
    if (keywordMatch) {
      warn(
        `avoid using JavaScript keyword as property name: ` +
        `"${keywordMatch[0]}"\n  Raw expression: ${text.trim()}`,
        range
      )
    } else {
      warn(
        `invalid expression: ${e.message} in\n\n` +
        `    ${exp}\n\n` +
        `  Raw expression: ${text.trim()}\n`,
        range
      )
    }
  }
}

 /*
 This code is checking if the expression passed in as a parameter to the function checkFunctionParameterExpression
 is valid. If it isn't, then we warn that there was an error with the expression and provide some context for where
 the error occurred. The code block checks if there are any errors when creating a new Function object using the 
 expression passed in as a parameter to this function. If there are no errors, then we do nothing because everything's fine.
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
function checkFunctionParameterExpression (exp: string, text: string, warn: Function, range?: Range) {
  try {
    new Function(exp, '')
  } catch (e) {
    warn(
      `invalid function parameter expression: ${e.message} in\n\n` +
      `    ${exp}\n\n` +
      `  Raw expression: ${text.trim()}\n`,
      range
    )
  }
}
