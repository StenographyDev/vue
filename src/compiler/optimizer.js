/* @flow */

import { makeMap, isBuiltInTag, cached, no } from 'shared/util'

let isStaticKey
let isPlatformReservedTag

const genStaticKeysCached = cached(genStaticKeys)

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
 /*
 This code is doing two things.
 First, it marks all the nonstatic nodes in the AST tree with a `isStatic` property. This will be used later to determine which nodes are static and which ones aren't.
 Second, it marks all the static roots of the AST tree with a `isStaticRoot` property. This will be used later to determine which nodes are static and which ones aren't.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
export function optimize (root: ?ASTElement, options: CompilerOptions) {
  if (!root) return
  isStaticKey = genStaticKeysCached(options.staticKeys || '')
  isPlatformReservedTag = options.isReservedTag || no
  // first pass: mark all non-static nodes.
  markStatic(root)
  // second pass: mark static roots.
  markStaticRoots(root, false)
}

 /*
 This code is creating a function that takes in an argument of type string.
 The code block creates a map with the following keys, separated by commas if there are more than one key.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
function genStaticKeys (keys: string): Function {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
    (keys ? ',' + keys : '')
  )
}

 /*
 This code is doing the following.
  It's checking if a node has children, and if it does, then it will mark all of its children as static.
  If a child doesn't have any children (i.e., there are no more nested nodes), then we check to see if that child is an element tag or not. If it isn't, then we know that this node should be marked as static because it won't change at runtime anyway.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
function markStatic (node: ASTNode) {
  node.static = isStatic(node)
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (let i = 0, l = node.children.length; i < l; i++) {
      const child = node.children[i]
      markStatic(child)
      if (!child.static) {
        node.static = false
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        const block = node.ifConditions[i].block
        markStatic(block)
        if (!block.static) {
          node.static = false
        }
      }
    }
  }
}

 /*
 This code is checking if the node has children. If it does, then we loop through each child and call markStaticRoots on them.
 If a child is not static, then we set the parent's staticRoot to false. This will cause this function to be called again for that node in the future when it gets visited by traversal functions like `traverse()`.
 This way, all nodes are marked as either being static or not depending on whether they have children or not.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
function markStaticRoots (node: ASTNode, isInFor: boolean) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true
      return
    } else {
      node.staticRoot = false
    }
    if (node.children) {
      for (let i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for)
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        markStaticRoots(node.ifConditions[i].block, isInFor)
      }
    }
  }
}

 /*
 This code is checking if the node has a `pre` property, which means that it's not an expression.
 If it doesn't have a `pre`, then we check to see if the node has bindings or vif/vfor/velse. If there are no bindings and no vif/vfor/velse, then we know that this is a static element (no dynamic binding).
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
function isStatic (node: ASTNode): boolean {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

 /*
 This code is checking if the node's parent has a tag of template and that it also has a for property.
 If both are true, then return true. Otherwise, return false.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
function isDirectChildOfTemplateFor (node: ASTElement): boolean {
  while (node.parent) {
    node = node.parent
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}
