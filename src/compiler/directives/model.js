/* @flow */

/**
 * Cross-platform code generation for component v-model
 */
 /*
 This code is doing the following.
 - generated by stenography autopilot [ 🚗👩‍✈️ ] 
 */
export function genComponentModel (
  el: ASTElement,
  value: string,
  modifiers: ?ASTModifiers
): ?boolean {
  const { number, trim } = modifiers || {}

  const baseValueExpression = '$$v'
  let valueExpression = baseValueExpression
  if (trim) {
    valueExpression =
      `(typeof ${baseValueExpression} === 'string'` +
      `? ${baseValueExpression}.trim()` +
      `: ${baseValueExpression})`
  }
  if (number) {
    valueExpression = `_n(${valueExpression})`
  }
  const assignment = genAssignmentCode(value, valueExpression)

  el.model = {
    value: `(${value})`,
    expression: JSON.stringify(value),
    callback: `function (${baseValueExpression}) {${assignment}}`
  }
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
 /*
 This code is doing the following.
 - generated by stenography autopilot [ 🚗👩‍✈️ ] 
 */
export function genAssignmentCode (
  value: string,
  assignment: string
): string {
  const res = parseModel(value)
  if (res.key === null) {
    return `${value}=${assignment}`
  } else {
    return `$set(${res.exp}, ${res.key}, ${assignment})`
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

let len, str, chr, index, expressionPos, expressionEndPos

type ModelParseResult = {
  exp: string,
  key: string | null
}

 /*
 This code is parsing the vmodel attribute and returning an object with two properties. The first property is exp, which represents the expression that will be used to update the model value. The second property is key, which represents a stringified version of the expression (e.g., `"{foo}.bar"`).
 - generated by stenography autopilot [ 🚗👩‍✈️ ] 
 */
export function parseModel (val: string): ModelParseResult {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim()
  len = val.length

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index = val.lastIndexOf('.')
    if (index > -1) {
      return {
        exp: val.slice(0, index),
        key: '"' + val.slice(index + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val
  index = expressionPos = expressionEndPos = 0

  while (!eof()) {
    chr = next()
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr)
    } else if (chr === 0x5B) {
      parseBracket(chr)
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

 /*
 This code is iterating through the string and returning each character as a number.
 - generated by stenography autopilot [ 🚗👩‍✈️ ] 
 */
function next (): number {
  return str.charCodeAt(++index)
}

function eof (): boolean {
  return index >= len
}

 /*
 This code is checking if the character at index 0 of the string `'abc'` is a quotation mark
 - generated by stenography autopilot [ 🚗👩‍✈️ ] 
 */
function isStringStart (chr: number): boolean {
  return chr === 0x22 || chr === 0x27
}

 /*
 This code is parsing the brackets in a string.
 - generated by stenography autopilot [ 🚗👩‍✈️ ] 
 */
function parseBracket (chr: number): void {
  let inBracket = 1
  expressionPos = index
  while (!eof()) {
    chr = next()
    if (isStringStart(chr)) {
      parseString(chr)
      continue
    }
    if (chr === 0x5B) inBracket++
    if (chr === 0x5D) inBracket--
    if (inBracket === 0) {
      expressionEndPos = index
      break
    }
  }
}

 /*
 This code is parsing a string. It's looking for the quote character, which is `chr`.
 It then looks at the next character in the stream and checks if it matches that same quote character. If so, we've found our end of string marker.
 If not, we keep going until we find our end of string marker or reach EOF (endoffile).
 - generated by stenography autopilot [ 🚗👩‍✈️ ] 
 */
function parseString (chr: number): void {
  const stringQuote = chr
  while (!eof()) {
    chr = next()
    if (chr === stringQuote) {
      break
    }
  }
}
