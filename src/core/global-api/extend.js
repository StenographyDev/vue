/* @flow */

import { ASSET_TYPES } from 'shared/constants'
import { defineComputed, proxy } from '../instance/state'
import { extend, mergeOptions, validateComponentName } from '../util/index'

 /*
 This code is creating a new Vue instance.
 The `new` keyword creates an empty object and then calls the constructor function on that object.
 This allows us to create a new instance of Vue without having to call `Vue()`.
 We can also use this method for inheritance, which we will discuss in the next section.
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
export function initExtend (Vue: GlobalAPI) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0
  let cid = 1

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    const Super = this
    const SuperId = Super.cid
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name)
    }

    const Sub = function VueComponent (options) {
      this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    cachedCtors[SuperId] = Sub
    return Sub
  }
}

 /*
 This code is creating a proxy for the prototype of the component.
 The first argument to `proxy` is the target object, which in this case is `Comp.prototype`.
 The second argument is an identifier that will be used as a key on the target object (in this case it's `_props`).
 The third argument is another identifier that will be used as a key on the proxy object (in this case it's `key`).
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
function initProps (Comp) {
  const props = Comp.options.props
  for (const key in props) {
    proxy(Comp.prototype, `_props`, key)
  }
}

 /*
 This code is creating a computed property on the prototype of the component.
 The key is the name of the computed property, and value is an object with two properties, get and set.
 The get function returns a function that will be called when we try to access this computed property.
 This returned function calls `this._getComputed(key)` which gets us our cached version of this computed property or computes it if it doesn't exist yet.
 - generated by stenography autopilot [ üöóüë©‚Äç‚úàÔ∏è ] 
 */
function initComputed (Comp) {
  const computed = Comp.options.computed
  for (const key in computed) {
    defineComputed(Comp.prototype, key, computed[key])
  }
}
