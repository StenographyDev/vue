/* @flow */

import {
  warn,
  nextTick,
  emptyObject,
  handleError,
  defineReactive
} from '../util/index'

import { createElement } from '../vdom/create-element'
import { installRenderHelpers } from './render-helpers/index'
import { resolveSlots } from './render-helpers/resolve-slots'
import { normalizeScopedSlots } from '../vdom/helpers/normalize-scoped-slots'
import VNode, { createEmptyVNode } from '../vdom/vnode'

import { isUpdatingChildComponent } from './lifecycle'

 /*
 This code is doing the following things.
  It defines a reactive property on vm called $attrs, which is an object that contains all attributes of the element.
  It defines a reactive property on vm called $listeners, which is an object that contains all event listeners of the element.
  The first argument to defineReactive() is always this instance of Vue (vm).
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
export function initRender (vm: Component) {
  vm._vnode = null // the root of the child tree
  vm._staticTrees = null // v-once cached trees
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree
  const renderContext = parentVnode && parentVnode.context
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  vm.$scopedSlots = emptyObject
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  const parentData = parentVnode && parentVnode.data

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, () => {
      !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm)
    }, true)
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {
      !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm)
    }, true)
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true)
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true)
  }
}

export let currentRenderingInstance: Component | null = null

// for testing only
 /*
 This code is setting the current rendering instance to be the vm that was passed in
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
export function setCurrentRenderingInstance (vm: Component) {
  currentRenderingInstance = vm
}

export function renderMixin (Vue: Class<Component>) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype)

 /*
 This code is using the nextTick function to call a callback after the current stack has completed
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
  Vue.prototype.$nextTick = function (fn: Function) {
    return nextTick(fn, this)
  }

  Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

 /*
 This code is setting the `$scopedSlots` property of the Vue instance to a normalized version of the scoped slots.
 The normalization process involves taking all slot names from both `vm.$slots` and `_parentVnode.data.scopedSlots`.
 It then creates an object with each key being a unique name, and value being an array containing either one or two elements depending on whether it's a named slot or not.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      )
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode
    // render self
    let vnode
 /*
 This code is doing the following.
  It's setting a variable called `currentRenderingInstance` to be equal to the current instance of Vue. This will allow us to access any data or methods that are attached to this specific instance of Vue, such as $data and $props.
  Then it calls the render method on our component with `vm.$createElement`.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm
      vnode = render.call(vm._renderProxy, vm.$createElement)
 /*
 This code is creating a new VNode.
 Second, it is setting the `_vnode` property of the vm to this vnode.
 Third, it is calling `vm.$options.render`. This method returns a VNode or an array of VNodes (if there are multiple root nodes). Fourth, we set the _vnode property on our component instance to be equal to that returned by render(). Fifth, we call handleError() and pass in any errors thrown from rendering as well as our component instance so that they can be logged if necessary. Finally, we return whatever was returned from render(), which could be either a single node or an array of nodes depending upon what was returned from render().
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
    } catch (e) {
      handleError(e, vm, `render`)
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
        } catch (e) {
          handleError(e, vm, `renderError`)
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    } finally {
      currentRenderingInstance = null
    }
    // if the returned array contains only a single node, allow it
 /*
 This code is checking if the vnode is an array and that it has a length of 1. If so, then we are setting the vnode to be equal to the first element in the array.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0]
    }
    // return empty vnode in case the render function errored out
 /*
 This code is checking if the vnode returned from render function is an instance of VNode. If it's not, then we're creating a new empty VNode and assigning it to vnode.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        )
      }
      vnode = createEmptyVNode()
    }
    // set parent
    vnode.parent = _parentVnode
    return vnode
  }
}
