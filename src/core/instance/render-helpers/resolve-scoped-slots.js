/* @flow */

 /*
 This code is creating a new object.
 Then, it is adding properties to that object. Then, it is returning the object.
 The first thing this function does is create an empty object and then adds properties to that object.
 This code also has two other things in addition to what we have seen so far  dynamic keys and content hash key. 
 Dynamic keys are used when you want your component's children to be able to dynamically change based on some condition (like if they are logged in or not). 
 Content hash key helps us keep track of which components need rerendering because their props changed but the child nodes didn't change at all (which means they don't need rerendering).
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
export function resolveScopedSlots (
  fns: ScopedSlotsData, // see flow/vnode
  res?: Object,
  // the following are added in 2.6
  hasDynamicKeys?: boolean,
  contentHashKey?: number
 /*
 This code is doing the following.
  It's creating a new object called `res`. This will be our result object that we'll return at the end of this function.
  If there are no dynamic keys, then it sets `res.$stable` to true (this means that if you don't have any dynamic keys in your vue slot, then it won't change). Otherwise, it sets `$stable` to false.
 - generated by stenography autopilot [ ğŸš—ğŸ‘©â€âœˆï¸ ] 
 */
): { [key: string]: Function, $stable: boolean } {
  res = res || { $stable: !hasDynamicKeys }
  for (let i = 0; i < fns.length; i++) {
    const slot = fns[i]
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys)
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true
      }
      res[slot.key] = slot.fn
    }
  }
  if (contentHashKey) {
    (res: any).$key = contentHashKey
  }
  return res
}
